<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="it">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="pandoc" />
		<title></title>
		<style type="text/css">code{white-space: pre;}</style>
		<style>
			.odd {
				background: #eee;
			}
			.talktable tr td {
				padding:.2em;
			}
			.quotation {
				background:#ccc;
				margin-left:4em;
				margin-right:4em;
				padding:2em;
			}
		</style>
	</head>
	<body>
		<table class="talktable">
			<thead>
				<tr class="header">
					<th>Slide</th>
					<th>Arialdo</th>
					<th>Nicola</th>
				</tr>
			</thead>
			<tbody>
				<tr class="odd">
					<td>1</td>
					<td>
						Ciao!
						<br />
						Questo sarà un talk un po' particolare, perché cercheremo di sostenere due tesi diametralmente opposte.
						<br />
						Io sono Arialdo, e reciterò la parte dell'<strong>architetto tradizionale</strong>.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td></td>
					<td></td>
					<td>Io sono Nicola, e proverò a vestire i panni dell'<strong>architetto agile</strong>.</td>
				</tr>
				<tr class="odd">
					<td>2</td>
					<td></td>
					<td>
						Cercheremo di far scontrare la visione &quot;Agile&quot;, che è la risposta ad una concezione taylorista del processo di sviluppo del software, con una visione, per così dire, più classica.
						<br />
						Il confonto tra mondo classico e mondo agile è molto vasto, ma nel corso della sessione proveremo a mantenere il focus su un unico tema, ovvero l'architettura.
						<br />
						Il problema, diciamocelo pure, è che l'architettura è un argomento molto fuffoso.
						<br />
						Pensa, anche un autore rispettato come Fowler arriva a pronunciare questa &quot;sentenza&quot;: <em>Nel nostro settore, 'architetto' ed 'architettura' sono termini terribilmente sovraccaricati di significati</em>&quot;.
						Ma, insomma, che cos'è l'architettura, Arialdo?</td>
				</tr>
					<tr class="even">
					<td>3</td>
					<td>
						Eh, bella domanda... Chiedetelo a tre architetti e otterrete quattro risposte differenti!
						<br />
						Posso provare a proporre questa, che forse è la definizione più formale che si possa trovare in letteratura:
						<p class="quotation">
						  &quot;<em>L'architettura è il più alto livello concettuale di un sistema nel proprio ambiente.</em>&quot;.</p>
						Che dici, può piacere ad un architetto &quot;Agile&quot;?</td>
					<td></td>
				</tr>
				<tr class="odd">
					<td>4</td>
					<td></td>
					<td>
						Assolutamente no.
						<br />
						Cosa significa il &quot;più alto livello concettuale&quot;?
						<br />
						Il più alto livello concettuale, per quanto mi riguarda, è quello degli <strong>utenti</strong> che utilizzano le nostre applicazioni.
						<br />
						Chiaramente, l'architettura non è qualcosa che dovrebbe riguardarli direttamente.
						<br />
						Senti, provo a riformulare leggermente la definizione che hai proposto, e lo faccio ricorrendo ad una piccolissima aggiunta:
						<p class="quotation">
						  &quot;<em>L'architettura è il più alto livello concettuale <strong>che gli sviluppatori hanno</strong> di un sistema nel proprio ambiente.</em>&quot;.</p>
						Può andarti bene in questo modo?
						<br />
						Altrimenti, scusate, ma rischiamo davvero di far apparire l'architettura come un qualcosa che, addirittura, trascende la figura dello sviluppatore; insomma, una sorta di &quot;stadio finale&quot; nel suo processo evolutivo.</td>
				</tr>
				<tr class="even">
					<td>5</td>
					<td>
						Sì, in qualche modo è proprio così: quando si ha a che fare con progetti complessi, è seriamente necessario un livello di astrazione elevato.
						<br />
						E, guarda, non si tratta di mettere
						&quot;<em>gli sviluppatori contro gli architetti</em>&quot;, ma di ottenere una crescita del sistema
						coordinata e armoniosa, cioè di garantire quella che io chiamo <em>integrità concettuale</em>.
						<br />
						E per poterla garantire è necessario avere un pensiero centrale.
						<br />
						Non sto parlando del pensiero di una singola persona. Anzi, se possiamo contare su un intero team di architetti, tanto di guadagnato.
						<br />
						Ma un punto di vista elevato, per studiare il sistema, serve: anche perché è molto improbabile che i singoli
						membri di un team abbiano le competenze sufficienti per assumere tutte decisioni.
						<br />
						E penso soprattutto alle decisioni più cruciali, quelle che devono essere prese con larghissimo anticipo.
						Invece, l'architetto, che ha conseguito questa maturità, è in grado di produrre un piano strategico da seguire.</td>
					<td></td>
				</tr>
				<tr class="odd">
					<td>6</td>
					<td></td>
					<td>
						Un piano, hai detto?
						<br />
						Quindi, l'architettura è una ricetta alla quale attenersi scrupolosamente?
						<br />
						Ma tu valuti la qualità di una torta assaggiandola. L'aderenza alla ricetta è una metrica davvero molto debole.</td>
				</tr>
					<tr class="even">
						<td>7</td>
						<td>
							È vero, però una ricetta serve comunque! Le torte non è che si realizzino mescolando ingredienti a caso, eh!
							<br />
							Sono pronto a scommettere che se assaggi una torta preparata senza seguire una ricetta te ne accorgi subito!
							<br />
							Allo stesso modo: costruire un sistema di grande  complessità senza un Enterprise Architect è come costruire una città senza un piano regolatore.
							<br />
							Ci si riesce?
							<br />
							Probabilmente sì.</td>
				</tr>
				<tr class="odd">
					<td>8</td>
					<td>
						Ma poi, ci andresti a vivere?
						<br />
						Probabilmente no.
						<br />
						Occhio, non sto dicendo che basti la presenza di un architetto e di un piano regolatore per garantire una città vivibile: dico solo che lo rendi molto più probabile. E che se decidi di farne a meno ti affidi sostanzialmente al caso.
					</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>9</td>
					<td></td>
					<td>
						La similitudine tra l'architettura civile e quella del software è molto ricorrente.
						<br />
						Sfortunatamente, è un'analogia che regge fino ad un certo punto.
						<br />
						Prima di tutto, tieni conto che l'architettuta &quot;tradizionale&quot; vanta secoli e secoli di storia alle sua spalle. Ci sono biblioteche intere sull'architettura civile.
						Il software, invece, ha una storia di poche decine di anni e c'è ancora un sostanziale mancanza di standard.
						<br />
						<br />
						Ma c'è dell'altro.
						<br />
						Guarda.
						Questo è il primissimo server di produzione Google&trade;. All'inizio, ospitava l'intera piattaforma.
						<br />
						Quella sotto, invece, è una foto scattata nemmeno 10 anni dopo, e rappresenta una piccola frazione della server farm che esiste oggi.
						<br />
						Queste immagini dovrebbero rendere l'idea di quanto sia cambiata Google&trade;, dalla sua nascita
						ai giorni nostri.
						<br />
						Se, al contrario, guardiamo, non so, l'Empire State Building, o una città, o un'autostrada, non si denotano cambiamenti architetturali così imponenti.
						<br />
						Sì, forse è proprio questa la sostanziale differenza tra l'architettura tradizionale e quella software: 
						l'architettura software deve essere pensata per evolvere nel futuro. Spesso, nell'immediato futuro! 
						<br />
						E, mi spiace: garantire l'<em>integrità concettuale</em>, come sostieni tu, non mi offre alcuna tutela in questo senso!</td>
				</tr>
				<tr class="odd">
					<td>10</td>
					<td>
						Quindi, l'evoluzione di Google&trade; è tutto frutto di design emergente, a colpi di TDD. È questo che dovrei concludere?
						<br />
						Che è sufficiente applicare una metodologia &quot;Agile&quot; per garantire, per esempio, la scalabilità di un sistema enterprise?
						<br />
						Senti questa storia:
						<p>
							Michele lavora in un'azienda enterprise, e nel suo lavoro ha sempre bisogno di dati molto specifici. 
							Sfortunatamente, questi dati sono distribuiti su diverse applicazioni. 
							<br />
							Quindi, appositamente per Michele, uno sviluppatore scrive un programma che recupera le
							informazioni da tre applicazioni, A, B e C e le fornisce a Michele in un file Excel, così che lui
							possa svolgere il proprio lavoro.
							<br />
							Michele, però, si accorge di aver bisogno di quei dati ogni giorno. Così chiede che
							il programma di raccolta venga eseguito, automaticamente, tutte le mattine.
							<br />
							Nessun problema: un sistemista aggiunge un'attività schedulata per Michele. 
							<br />
							Ecco: il risultato è che, appositamente per Michele, è stato creato un vero &quot;Application Workflow&quot;, che dipende da tre applicazioni e da un'attività schedulata.
							<br />
							Il fatto è che Michele non è il solo in azienda a voler aumentare la propria produttività.
							<br />
							Moltiplica la situazione di Michele per un migliaio di volte.</p>
						Il risultato è questo: un'&quot;Architettura a matassa&quot;, un immenso piatto di spaghetti.
						<br />
						È un blob con fibre di connessione che vanno in ogni possibile direzione. Nessuno
						è in grado di districarlo, e nessuno ne ha controllo.
						<br /><br />
						Ora, supponiamo di aver bisogno di sostituire una delle applicazioni chiave, perché la sua tecnologia
						è datata o perché il fornitore interromperà il supporto.
						<br/>
						Ci sarà difficile, se non impossibile, capire quali siano le connessioni con quell'applicazione.
						<br />
						Hai una rete infinita di dipendenze e, ironicamente, siamo noi stessi ad averla prodotta, anno dopo anno.
						<br />
						Ognuna delle connessioni era perfettamente ragionevole, nel momento in cui è stata introdotta, ma il risultato finale è talmente contorto che risulta impossibile apportare modifiche in un punto senza provocare danni in un altro.</td>
				</tr>
				<tr class="even">
					<td></td>
					<td></td>
					<td>
						Capperi, ho l'impressione che qualcuno si sia divertito a violare deliberatamente i principi cardine di Object Oriented: altissimo accoppiamento, bassissima coesione. La reificazione dello &quot;spaghetti code&quot;.
					</td>
				</tr>
				<tr class="odd">
					<td>11</td>
					<td>
						Ecco, è qui che opera <em>Enterprise Architecture</em>: aiuta a creare un ecosistema organizzato in modo che ognuno abbia la libertà di apportare miglioramenti, mantenendo comunque l'ecosistema robusto e flessibile.
						Ed è impossibile pensare di ottenere un risultato simile senza un processo che coordini tutte le azioni.</p>
					<td></td>
				</tr>
				<tr class="odd">
					<td>12</td>
					<td>
						Un'azienda come Apple&trade;, quando decide di inventare il concetto di smartphone e di sviluppare un sistema operativo, parte da una strategia di business, disegnata dall'amministratore delegato e poi la trasforma in un piano di sviluppo tecnologico. L'architettura serve a quello: c'è un legame a doppio filo tra
						strategia di business e strategia tecnologica. Le scelte di business dell'azienda guidano le scelte tecnologiche, 
						ma sono proprio i risultati tecnologici che consentono al business di realizzare
						le strategie.
						<br />
						L'archittetura, quindi, va anche un po' al di là del codice: serve ad
						allineare tecnologia e business.
						<br />
						E, in questo senso, la centralità del pensiero è molto più sensata di una totale mancanza di coordinamento.
						<br />
						È difficile credere che il sistema operativo di iPhone&trade; sia emerso dai team di sviluppo, a colpi di TDD.
						<br />
						O è questo quello che sostiene Agile?
						<td></td>
				</tr>
				<tr class="even">
					<td>13</td>
					<td></td>
					<td>
						No, non è questo.
						<br />
						Ma, può darsi, che anche la &quot;centralizzazione del pensiero&quot; non sia sufficiente a risolvere il problema, poiché introduce più problemi di quelli che cerca di risolvere.
						<br />
						È vero, &quot;Enterprise Architecture&quot; sta coinvolgendo sempre di più le istituzioni finanziarie nel mondo.
						Eppure c'è chi sostiene quanto segue:
						<p class="quotation">
							&quot;<em>La maggioranza delle iniziative Enterprise Architecture ha fallito. Io stimo che in più del 90% dei casi non sia stato realizzato niente di utile.</em>
							<br /> 
							<em>L'architettura ha molto più a che fare con la <strong>conoscenza condivisa</strong> e con la <strong>visione comune</strong> ed ha una connotazione più 'sociale' che tecnica</em>&quot;.</p></td>
				</tr>
				<tr class="odd">
					<td></td>
					<td>
						Ok, queste erano le parole di uno di quei guru
						&quot;Agile&quot; che occupano i palcoscenici delle conferenze raccontando che i manager sono inutili, che il mondo è degli sviluppatori e che dovremmo iniziare tutti quanti ad abbracciare gli alberi.
						<br />
						Vero?</td></td>
					<td></td>
				</tr>
				<tr>
					<td>14</td>
					<td></td>
						<td>
						  Guarda, stenterai a crederlo, ma l'autore è, in realtà, <em>Ivar Jacobson</em>, uno dei maggiori &quot;contributor&quot; di UML, uno strumento piuttosto osteggiato da &quot;Agile&quot;.
				</tr>
				<tr class="odd">
					<td>15</td>
					<td>
						Ok, capisco.
						<br />
						Parliamo, allora, di quello che &quot;Agile&quot; propone, in alternativa ad &quot;Enterprise Architecture&quot;.
						<br />
						&quot;Agile&quot;, in qualche modo, simpatizza con l'idea di una struttura organizzativa piatta.
						<br />
						E, lo riconosco, è un'idea intrigante perché fa riferimento a principi molto democratici e accattivanti.
						<br />
						Però è anche un'idea molto naive.
						<br />
						Io non adotto una metodologia in base a quanto sia affascinante o alla moda.
						<br />
						Sicché, anche se rischio di apparire un po' cravattone, preferisco basare le mie scelte su proposizioni scientifiche.
						<br />
						Al che mi domando: qual è il fondamento scientifico di quello che &quot;Agile&quot; sostiene?
						<br />
						Io vi dico, da parte mia, perché avverto la necessità di un &quot;livello di astrazione&quot; elevato.
						<br />
						Conoscete il modello <em>Dreyfus</em> di &quot;acquisizione delle competenze&quot;?
						<br />
						È stato ideato negli anni 80 da due docenti californiani. Non è una teoria campata per aria: anzi, ha avuto un grande impatto in campo infermieristico e aziendale.
						<br />
						Secondo questo modello, quando affrontiamo un problema nuovo, passiamo attraverso cinque fasi.
						<br />
						Inizialmente ci limitiamo ad applicare meccanicamente le regole.
						<br />
						Poi, gradualmente, acquisiamo autonomia e finiamo perfino per abbandonare del tutto le regole e affidarci all'intuito.
						<br />
						<br />
						Guardate: alla base della piramide c'è il <em>novizio</em>. Aderisce alle regole: gli si dice cosa fare, e lui si limita ad eseguire, senza porsi troppe domande.
						<br />
						Ad un livello sopra c'è il <em>principiante</em>: segue le regole, come il novizio, ma inizia anche contestualizzarle nelle varie situazioni e a porsi quesiti. È il caso del programmatore junior, che può affrontare autonomamente lo sviluppo di un componente se gli si danno specifiche chiare, anche se, chiaramente, non è in grado di progettarlo da zero in autonomia.
						<br />
						Poi ci sono i <em>competenti</em>: persone capaci di gestire la complessità, capaci di comprendere le conseguenze a lungo termine delle proprie azioni, eventualmente senza coglierne tutte le implicazioni.
						<br />
						Arriviamo, poi, ai <em>proficient</em>: sono tecnici che finalmente affrontano il problema con una prospettiva differente, con un approccio olistico e sistemico. Sono professionisti che, osservando l'albero, sono in grado di visualizzare l'intera foresta.
						<br />
						Infine, abbiamo gli <em>esperti</em>, che adottano un approccio largamente intuitivo e ricorrono a mezzi analitici solo all'occorrenza, prevalentemente in situazioni nuove.
						<br />
						Ecco, i compiti di un architetto richiedono questo livello.
						<br />
						L'idea che non vi sia  bisogno di ruoli specifici - che in fondo, di fronte alla complessità, <em>siamo tutti uguali</em>, tutti architetti - è molto romantica, ma manca di fondamento scientifico.</td>
				</tr>
				<tr class="even">
					<td>16</td>
					<td></td>
					<td>
						Ok.
						<br />
						Guarda, posso essere anche d'accordo.
						Ad un certo punto, però, hai parlato di &quot;sviluppatori che dovrebbero occuparsi dello sviluppo di un singolo componente&quot; e, su questo argomento, vorrei raccontarti un aneddoto, che dimostra quanto, invece, l'architettura dovrebbe essere qualcosa che vada a coinvolgere tutti.
						<br />
						Guardate un po' questo snippet: si tratta di una classica operazione di &quot;prelievo&quot; fondi.
						<br />
						Riuscite ad individuare la falla?</td>
				</tr>
				<tr class="even">
					<td></td>
					<td>
						Se il database supporta transazioni ACID, con un livello di isolamento adeguato, io non vedo problemi.
						<br />
						In caso contrario, accessi concorrenti possono originare una &quot;Race Condition&quot;.
						<br />
						Provo a simulare il caso.
						<br />
						Supponiamo che sul conto vi sia un bilancio di 1.000 EURO.
						<br />
						Mi connetto e decido di prelevare 100 EURO.
						<br />
						Quindi, in prima battuta, &quot;balance&quot; vale 1.000,  &quot;amount&quot; vale 100.
						Per cui, &quot;new_balance&quot;, varrà 900.
						<br />
						Ora, prima di scrivere il valore di &quot;new_balance&quot; sul database, con una seconda connessione accedo al medesimo conto, e chiedo, ancora una volta, di ritirare 100 EURO.
						<br />
						La prima riga viene nuovamente eseguita e sul database risulta ancora un bilancio pari a 1.000 EURO.
						<br />
						Che dire... fantastico! Sono in grado di prelevare 200 euro, e me ne faccio addebitare solo 100!</td>
					<td></td>
				</tr>
				<tr class="odd">
					<td></td>
					<td></td>
					<td>
						Esattamente!
						<br />
						In quel caso, la Race Condition si manifestava poiché l'engine era MongoDB, che non consente in qualche modo di &quot;serializzare&quot; l'accesso ai documenti, benchè supporti pienamente operazioni di incremento atomiche.
						<br />
						Ora, quel codice apparteneva a &quot;Flexcoin&quot;, una &quot;Bitcoin bank&quot;.
						<br />
						Un attacker è riuscito a sfruttare la Race Condition, dilapidando i forzieri della banca,
						per un totale di circa mezzo milione di dollari.
						La conclusione di questa spiacevole vicenda è stata che, a marzo di quest'anno, &quot;Flexcoin&quot; ha chiuso i battenti.
						<br />
						<br />
						Riflettendoci bene, tutto questo si traduce in un fallimento quasi &quot;sociale&quot;: è
						il fallimento di un insegnamento accademico dei sistemi distribuiti con il quale abbiamo educato gli sviluppatori a fidarsi ciecamente di framework e strumenti preconfezionati, così che potessero prescindere dagli aspetti architetturali. Tutto questo nella speranza, come sostieni tu, che potessero occuparsi in autonomia dello <em>sviluppo del singolo componente</em>.</td>
				</tr>
				<tr class="even">
					<td></td>
					<td></td>
					<td>
						Detto questo, a me pare evidente che partiamo da basi molto differenti.
						<br />
						Possiamo riassumere asserendo che facciamo riferimento a due figure molto differenti di architetto?</td>
				</tr>
				<tr class="odd">
					<td>17</td>
					<td>
						Sì, il mio architetto è la persona che prende le decisioni importanti, quelle di più alto livello.
						È la persona che si sarebbe assicurata di utilizzare un database che supporti le transazioni, proprio per evitare incidenti come quello di &quot;Flexcoin&quot;.
						<br />
						Chiamiamolo <em>Accountable Architect</em>.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>18</td>
					<td></td>
					<td>
						Il mio lo definirei <em>Pragmatic Architect</em>.
						<br />
						E, il mio architetto, non così interessato a prendere personalmente decisioni.</td>
				</tr>
				<tr class="odd">
					<td>19</td>
					<td></td>
					<td>
						L'attività più importante del mio architetto è quella di fare da mentore per i team,
						in modo tale da consentire a ciascuno dei loro membri di raggiungere un livello di competenze tale da permettergli di affrontare autonomamente problematiche sempre più complesse.
						<br />
						E, attenzione, quando parlo di &quot;mentoring&quot; non parlo di guidare stand-up meeting e retrospettive, o di insegnare a dimensionare e &quot;splittare le user story&quot;. Quella è la parte meno interessante di &quot;Agile&quot;.
						<br />
						Chissà per quale motivo, si presta sempre poca attenzione al &quot;b-side&quot; del manifesto, dove si fa un preciso riferimento alla &quot;continua attenzione all'eccellenza tecnica&quot;.
						Ecco, proprio incrementare le abilità tecniche dei team consente all'architetto di svincolarsi dall'incombenza di fungere da solo &quot;decision maker&quot; e rimuove il rischio di gravare sull'intero processo come &quot;collo di bottiglia&quot;.</td>
				</tr>
				<tr class="even">
					<td>20</td>
					<td></td>
					<td>
						La metafora che mi sembra più appropriata è quella proposta da Mike Two: l'architetto come una &quot;guida alpina&quot;; è la persona più skillata, che può insegnare agli altri membri come muoversi ed è sempre un riferimento nei momenti di maggior difficoltà.</td>
				</tr>
				<tr class="odd">
					<td>21</td>
					<td></td>
					<td>
						In questo senso, credo che il valore di un architetto sia inversamente proporzionale alla quantità di decisioni che è costretto a prendere.
						<br />
						E, pensandoci bene, è una figura molto simile al Coach in eXtreme Programming.
						<br />
						In sostanza, l'architetto realizza il suo compito quando ha reso il team autonomo.
					</td>
				</tr>
				<tr class="even">
					<td>22</td>
					<td>Quindi, stiamo parlando di una figura che si adopera per rendersi superflua ed inutile?</td>
					<td></td>
				</tr>
				<tr class="odd">
					<td></td>
					<td></td>
					<td>In un certo senso, sì.</td>
				</tr>
				<tr class="even">
					<td>23</td>
					<td>
						A me sembra tutto piuttosto fumoso e un po' distante dalle esigenze reali delle aziende enterprise. Però ne colgo il senso.
						<br />
						Diciamo che il mio architetto, sul piano puramente operativo, quello vicino al codice, è meno impegnato dell'architetto &quot;Agile&quot;.
						Magari, è più interessato a creare una visione comune, allineata alle scelte di business.
						<br />
						Per cui, forse è vero, non è presente alle singole scalate e lascia questo compito a degli alpini professionisti.
						Ecco, diciamo che il mio architetto è quello che fornisce alla tua spedizione una cartina affidabile.
						<br />
						La guida, in un team, è indispensabile ma, ecco, senza una mappa porterà l'intera spedizione in direzione sbagliata.
						<br />
						Sapete perché credo che un lavoro di design up-front sia davvero molto importante?</td>
				</tr>
				<tr class="odd">
					<td>24</td>
					<td>
						Perché esistono delle decisioni che vanno prese con largo anticipo, prima che sia troppo tardi; prima di scoprire che le fondamenta sulle quali il progetto si regge sono inconsistenti. 
						<br />
						Queste sono le classiche fasi di sviluppo di un progetto, che vanno dal <em>concept</em>, alla raccolta dei requisiti, allo sviluppo e così via.
						<br />
						La mia tesi è che, con il passare del tempo, il costo da sostenere per apportare una modifica aumenti. Cioè, col passare del tempo aumenti l'irreversibilità del processo.
						<br />
						Ecco, quello è il compito dell'architetto: definire quegli aspetti del design che sono più costosi da cambiare in corso d'opera. Fare le scelte più irreversibili</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>25</td>
					<td></td>
					<td>
						Probabilmente è questo il punto cruciale: si possono vedere le metodologie &quot;Agile&quot; come un sistema volto al contenimento della complessità e alla riduzione dell'irreversibilità.
						<br />
						Classicamente, la complessità viene affrontata con la pianificazione: si cerca di minimizzare l'impatto negativo del cambiare idea in corso d'opera.
						<br />
						Una delle poche cose che ho imparato in questi anni è che il cambiamento è inevitabile.
						<br />
						Punto.
						<br />
						Anzi, sai una cosa? Ultimamente ho imparato ad abbracciarlo e, addirittura, ad incoraggiarlo!
						<br />
						Mi trasmette l'idea che l'azienda per cui lavoro sia dinamica. E questo è dannatamente importante!
						<br />
						Quindi, io devo adoperarmi per affrontarlo e gestirlo.
						<br />
						Chi ritiene di poterlo gestire con una mera pianificazione, produce piani come questo:</td>
				</tr>
				<tr class="odd">
					<td>26</td>
					<td></td>
					<td>
						Sfortunatamente, per quante energie si investano nel predirre il futuro, la strada che ci troveremo a percorrere assomiglierà più a questa:</td>
				</tr>
				<tr class="even">
					<td>27</td>
					<td></td>
					<td>
						Per questo motivo, quello che potrai anticipare del futuro sarà al massimo:
						<br />
						Io, invece, faccio leva sullo &quot;scope&quot;; avanzo per &quot;piccoli passi&quot;.
						<br />
						Kent Beck usa una metafora molto convincente: quella della &quot;guida&quot;.
						<br />
						&quot;<em>Guidare non è una questione di puntare la macchina nella giusta direzione.
						Guidare riguarda dare attenzione costante, apportando piccole correzioni prima in una direzione, e poi in un'altra.
						<br />
						Questa è l'essenza di XP: il cambiamento è l'unica costante.</em>&quot;.</td>
				</tr>
				<tr class="odd">
					<td>28</td>
					<td>
						Di nuovo, mi sembra un po' troppo vago.
						<br />
						È dagli anni 80 che è stato dimostrato che il costo del software aumenta nel tempo.
						<br />
						Modificare il software in fase di analisi è molto, molto più economico che in fase di sviluppo. Una volta arrivati alla produzione, poi, il costo diventa proibitivo.
						<br />
						Quindi, molto meglio individuare un problema durante la raccolta dei requisiti, prima che il danno si manifesti in produzione.
						<br />
						Perciò, un'analisi up-front può essere davvero lo strumento che permette di contenere i costi di gestione.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>29</td>
					<td></td>
					<td>
						La scommessa di <em>eXtreme Programming</em> è proprio questa: appiattire
						la curva dei costi, e fare in modo che cambiare il codice consista sempre in un'operazione economica; in fase di design come in produzione.
						Appiattire la curva dei costi ci consente di comportarci in maniera totalmente differente da come siamo abituati a comportarci.
						<br />
						Ad esempio, piuttosto che pianificare tutto al minimo dettaglio, potremmo rimandare le decisioni al &quot;Last Responsible Moment&quot;, semplicemente per avere più tempo a disposizione per indagare sul problema.
						<br />
						L'architetto può passare dall'obiettivo di <em>produrre piani</em> a quello di <em>creare le condizioni che consentano ai piani di svilupparsi</em>, giorno dopo giorno. E, certo, si tratta di uno shift culturale enorme.</td>
				</tr>
				<tr class="odd">
					<td>30</td>
					<td>
						Enterprise Architecture non è contraria a TDD. La questione è: queste tecniche sono sufficienti a far <strong>emergere</strong> un'architettura?
						<br />
						Puoi essere un eccellente muratore e saper erigere case robuste e accoglienti.
						Anzi, è necessario che ci siano artigiani qualificati.
						<br />
						Ma mille muratori non garantiscono una città con una tangenziale senza ingorghi di traffico. Si parla di due piani differenti, capite? Codice da una parte, sistema dall'altra.
						<br />
						Cosa propongono di diverso, i nostri due architetti, per costruire, debuggare e manutenere un sistema informatico con un alto grado di complessità?</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>31</td>
					<td>
						Io suggerisco che si ricorra ad un'autorità, un esperto che possa occuparsi di disegnare il sistema senza doversi occupare dei dettagli implementativi, perché è evidente che il suo tempo sarà particolarmente prezioso.
						Fintanto che il team sarà in grado di seguire le linee guida, la qualità del sistema verrà garantita.</td>
					<td></td>
				</tr>
				<tr class="odd">
					<td>32</td>
					<td></td>
					<td>
						Al contrario, io ritengo che questo approccio porti a rallentamenti e finger pointing.
						In un contesto del genere, risulta evidente che, in una discussione, colui che è investito di maggiore autorità ne uscirà sempre vincitore.
						E c'è di peggio: gli sviluppatori verranno accusati di non essere buoni &quot;team player&quot;, solo perché hanno contestato l'architetto.</td>
				</tr>
				<tr class="even">
					<td>33</td>
					<td></td>
					<td>
						Piuttosto, propongo che l'architetto sia coinvolto anche nella fase implementativa. È necessario che sia costantemente informato sui cambiamenti e sull'impatto che questi producono sul design.</td>
				</tr>
				<tr class="odd">
					<td>34</td>
					<td>
						Esasperando le diversità dei due approcci, mi sembra di capire che il nodo della questione è questa: io propongo la figura di un architetto dedicato.</td>
				</tr>
				<tr class="even">
					<td>35</td>
					<td></td>
					<td>E io faccio invece leva sulla condivisione della responsabilità.</td>
				</tr>
				<tr class="odd">
					<td>36</td>
					<td>Io pongo maggiore attenzione sul design-upfront.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>37</td>
					<td></td>
					<td>E io su un'architettura evolutiva.</td>
				</tr>
				<tr class="odd">
					<td>38</td>
					<td>Oppure, per usare le parole del &quot;Manifesto Agile&quot;, io faccio affidamento sulla <em>Comprehensive Documentation</em>.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td></td>
					<td></td>
					<td>Io, invece, mi affido alla concretezza del <em>Working Software</em>.</td>
				</tr>
				<tr class="odd">
					<td></td>
					<td>
						Bene.
						<br />
						Ecco, fammi capire perché l'architetto dovrebbe restare costantemente informato anche sui dettagli implementativi.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>39</td>
					<td></td>
					<td>
						Certamente.
						<br />
						E, per spiegarlo, vorrei ricorrere agli <em>influence diagram</em>.
						<br />
						Considera il rapporto tra il mangiare e il prendere peso. Più mangio, più ingrasso. è una influenza positiva. La rappresento in questo modo:</td>
				</tr>
				<tr class="odd">
					<td>40</td>
					<td></td>
					<td>
						Il rapporto tra l'esercizio fisico e il peso è opposta: più sport pratico, più perdo peso.
						<br/>
						In questo caso, si tratta di un'influenza negativa e la rappresento sovrapponendo un cerchio alla linea. Mi segui?</td>
				</tr>
				<tr class="even">
					<td>41</td>
					<td></td>
					<td>
						Ok, come puoi notare ho rappresentato un circolo vizioso.
						<br />
						Parti dalla freccia che entra nel circolo e leggi il diagramma in questo modo:
						<br />
						Più mangio, più ingrasso.
						<br />
						Più ingrasso, più perdo stima in me stesso.
						<br />
						Più perdo stima in me stesso, più mangio.
						<br />
						Più mangio, più aumento di peso. Ed ecco che mi ritrovo nuovamente all'ingresso del circolo vizioso.</td>
				</tr>
				<tr class="odd">
					<td></td>
					<td>Scusa, ma perché mi racconti questo?</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>42</td>
					<td></td>
					<td>
						Ci arrivo.
						<br />
						Guarda, quì ho rappresentato lo stesso identico circolo vizioso, ma ho usato dei termini che riguardano il ciclo di sviluppo del software. Leggilo così:
						<br />
						Più pressioni vengono imposte al team, più gli sviluppatori praticheranno &quot;cowboy programming&quot;. Probabilmente, la suite di test risulterà carente e di pessima qualità.
						<br />
						Il cowboy programming avrà un effetto negativo sulla qualità del codice, ragion per cui si produrrà un codice tendenzialmente meno corretto.
						<br />
						Arrivati a questo punto, probabilmente si farà maggior pressione; non so, anche solo per rispettare le scadenze.
						<br />
						E, guarda, si tratta di un circolo vizioso.</td>
				</tr>
				<tr class="odd">
					<td></td>
					<td>D'accordo.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>43</td>
					<td></td>
					<td>
						Ecco, adesso cercherò di mostrarti perché l'architetto debba essere coinvolto anche nello sviluppo.
						<br />
						Questo diagramma di influenza descrive il tuo approccio:
						<br />
						Parti dalla freccia in ingresso al diagramma, cioè dalla decisione di produrre molta documentazione.
						<br />
						Tanta più documentazione l'aarchitetto produce, minore è il numero di feedback diretti che riceve;
						<br />
						Meno feedback ricevi, maggiore sarà il numero di scelte errate compiute dal team.
						<br />
						E, a fronte di un alto numero di cattive scelte, ti troverai a produrre ulteriore documentazione.
						<br />
						Come vedi, anche in questo caso siamo di fronte ad un circolo vizioso.</td>
				</tr>
				<tr class="odd">
					<td></td>
					<td>E tu cosa proponi in alternativa?</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>44</td>
					<td></td>
					<td>
						Beh, devo invertire la tendenza, e ti mostro come approccerei io.
						<br />
						Il mio architetto farebbe leva su una collaborazione molto intensiva, piuttosto che sul produrre documentazione.
						Facendo leva sulla collaborazione, produco molti feedback, riducendo così il numero di scelte errate.
						<br />
						Ed ecco che il ridurre le scelte errate mi consente di abbattere il numero di documenti prodotti e, quindi, di avere maggior tempo a disposizione per la collaborazione intensiva.
						<br />
						Come puoi constatare, il modello che propongo alimenta un circolo virtuoso!</td>
				</tr>
				<tr class="odd">
					<td></td>
					<td>Quindi, quale è l'alternativa ad &quot;Enterprise Architecture&quot;?</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>45</td>
					<td></td>
					<td>
						Agile propone: <em>Gli individui e le interazioni, più che i processi e gli strumenti</em>.
						<br /><br />
						Spesso, al governo centralizzato si accompagna la tendenza a standardizzare e a convergere verso una singola piattaforma tecnologica.
						<br />
						Ma l'esperienza ci insegna che non tutti i problemi sono chiodi e, di conseguenza, non tutte le soluzioni sono martelli.
						<br />
						Il trend, in questi anni, è di costruire sistemi organizzati come micro-service.
						<br />
						Molti team, piuttosto che affidarsi a standard scritti su qualche documento, da qualcuno sopra di loro, preferiscono produrre tool utili che altri sviluppatori possano utilizzare per risolvere problemi simili. 
						<br />
						Nascono le API e, assieme a loro, delle &quot;community&quot;.
						<br />
						Se ci pensi bene, Amazon&trade; rappresenta un caso molto significativo.</td>
				</tr>
				<tr class="odd">
					<td>46</td>
					<td>
						Sono molto d'accordo.
						<br />
						E penso sia molto curioso che tu concluda citando Amazon&trade;.
						<br />
						Perché, ricorderai che Amazon&trade; è passata dall'essere un e-commerce di libri ad una piattaforma di servizi per la decisione illuminata ed autoritaria di un architetto visionario e dispotico.
						<br />
						Probabilmente, se si fosse aspettata questa trasformazione
						per l'intervento dei suoi singoli sviluppatori, come architettura emergente, oggi non avremmo il &quot;Cloud&quot; di Amazon&trade;.
						<br />
						Ma è bello vedere che le nostre visioni, apparentemente così distanti, abbiano alla fine così tanti punti di contatto.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>47</td>
					<td></td>
					<td>
						È vero, ma a quale conclusione siamo giunti?
						<br />
						Che &quot;Agile&quot; è una visione diametralmente opposta all'architettura &quot;classica&quot;? Essere &quot;Agile&quot; preclude ogni accesso a &quot;Enterprise Architecture&quot;?
						<br />
						Non potremmo, invece, semplicemente ammettere che le due visioni affrontano il medesimo problema da due prospettive differenti? E che entrambe, in un certo senso, si completano vicendevolmente?
						<br />
						Forse, davvero abbiamo bisogno di entrambe le attività, e il nostro compito è quello di farle incontrare; magari, a metà strada.
						<br />
						Naturalmente, non abbiamo &quot;LA&quot; risposta.
						Detto questo, se, ora che siamo giunti al termine del talk, qualcuno di voi si sta ponendo dei quesiti, allora direi che abbiamo raggiunto il nostro obiettivo.
						E, forse, abbiamo ancora qualche minuto per discuterne assieme.</td>
				</tr>
			</tbody>
		</table>
	</body>
</html>
