<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="it">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="pandoc" />
		<title></title>
		<style type="text/css">code{white-space: pre;}</style>
		<style>
			.odd {
				background: #eee;
			}
			.talktable tr td {
				padding:.2em;
			}
			.quotation {
				background:#ccc;
				margin-left:4em;
				margin-right:4em;
				padding:2em;
			}
		</style>
	</head>
	<body>
		<table class="talktable">
			<thead>
				<tr class="header">
					<th>Slide</th>
					<th>Arialdo</th>
					<th>Nicola</th>
				</tr>
			</thead>
			<tbody>
				<tr class="odd">
					<td>1</td>
					<td>
						Ciao!
						<br />
						Questo sarà un talk un po' particolare, perché cercheremo di sostenere due tesi diametralmente opposte.
						<br />
						Io sono Arialdo, e reciterò la parte dell'<strong>enterprise architect</strong>.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td></td>
					<td></td>
					<td>Io sono Nicola, e proverò a vestire i panni dell'<strong>agile architect</strong>.</td>
				</tr>
				<tr class="odd">
					<td>2</td>
					<td></td>
					<td>
						Parlaremo di architettura, partendo da due posizioni molto distanti.
						<br /><br />
						Sapete meglio di me che Agile è nata come reazione ad un certo modo un po' industriale e taylorista di vedere il software.
						L'argomento è immenso: noi però cercheremo di parlare solo di un singolo aspetto, dell'architettura e  delle differenze che ci sono
						tra la visione agile e la visione, per così dire, più classica.
						<br /><br />
						Il fatto è che l'architettura è un argomento molto vago e anche un po' fuffoso.
						<br /><br />
						&quot;<em>'Architetto' ed 'architettura' sono parole terribilmente sovraccaricate di significati</em>&quot;.
						<br /><br />
						dice Fowler.</td>
				</tr>
					<tr class="even">
					<td>3</td>
					<td>
						Ed è verissimo, Fowler ha ragione.
						<br />
						Cos'è l'archittetura? Chiedilo a 3 architetti, ti daranno 4 risposte differenti.
						<br /><br />
						Faccio questo tentativo:
						<br /><br />
						<div class="quotation">
						  &quot;<em>L'architettura è il più alto livello concettuale di un sistema nel proprio ambiente.</em>&quot;
						  </div>
						<br /><br />
						Questa è la definizione di IEEE. In informatica ha una certa autorità.
						<br /><br />
						È una definizione che può soddisfare la visione Agile?</td>
					<td></td>
				</tr>
				<tr class="odd">
					<td>4</td>
					<td></td>
					<td>
						Per niente
						<br /><br />
						Cioè, io trovo che questa definizione faccia riferimento a qualcosa che arriva addirittura a trascendere la professione dello sviluppatore.
						<br />
						Insomma, da come è presentata, sembra che l'architettura rappresenti lo stadio finale nel suo processo evolutivo!</td>
				</tr>
				<tr class="even">
					<td>5</td>
					<td>
						Sì, è così, in effetti.
						<br />
						O meglio, la mia tesi è che, in progetti software complessi, un livello di astrazione elevato sia davvero necessario.
						<br />
						E mi stupisco che in Agile non sia accettabile, perché non è un problema di &quot;sviluppatori contro architetti&quot;, ma una questione di conquistare di un'<em>integrità concettuale</em>.
						<br /><br />
						<br /><br />
						<div class="quotation">
							&quot;<em>Per garantire l'integrità concettuale è necessario un pensiero centrale</em>&quot;.
						</div>
						<br /><br />
						Non sto parlando di una singola persona. Anzi, se possiamo contare su un comitato di persone,  tanto di guadagnato.
						<br /><br />
						Perché dico che è necessaria una centralità?
						Perché è molto probabile che i membri di un team non abbiano le competenze sufficienti per 
						prendere certe decisioni. Parlo delle decisioni più cruciali, quelle che devono essere prese con larghissimo anticipo.
						Per cui l'architetto, che invece ha questa maturità e, soprattutto, il tempo a disposizione, può essere in grado di fornire a tutti un piano da seguire.
						</td>

					<td></td>
				</tr>
				<tr class="odd">
					<td>6</td>
					<td></td>
					<td>
						Un piano da seguire?
						<br />
						Quindi, l'architettura è una ricetta alla quale attenersi scrupolosamente?
						<br />
						Ma non è forse vero che...
						<br /><br />
						<div class="quotation">
							&quot;<em>la qualità di una torta la si valuta assaggiandola. L'aderenza alla ricetta è una metrica molto debole</em>&quot;.
						</div>
					</td>
				</tr>
					<tr class="even">
						<td>7</td>
						<td>
							Ci mancherebbe!
							<br />
							Eppure, una ricetta è necessaria! Le torte non si realizzano mescolando ingredienti a caso.
							<br /><br />
							<div class="quotation">
								&quot;<em>Costruire un sistema enterprise di grandi dimensioni e complessità senza un <strong>Enterprise Architect</strong> è come tentare di costruire una città senza un piano regolatore.
								<br /><br />
								È possibile costruire una città senza un piano?
								<br />
								Probabilmente.
								<br /><br />
								Andreste a vivere in quella città?
								<br />
								Probabilmente no.
								<br /><br />
								Ovviamente, un architetto che disegni un piano regolatore non garantisce una città vivibile: semplicemente, ne aumenta le probabilità.</em>&quot;
							</div>
						</td>
						<td></td>
					</tr>
				<tr class="odd">
					<td>8</td>
					<td></td>
					<td>
						La similitudine tra l'architettura civile e quella del software è molto ricorrente.
						<br />
						Sfortunatamente, è una metafora che regge fino ad un certo punto.
						<br /><br />
						Questo è il primissimo server di produzione Google&trade;. Faceva girare l'intera piattaforma, fino a pochi anni fa.
						<br />
						Quella sotto, invece, è una foto scattata nemmeno 10 anni dopo, ed è una piccola frazione della server farm che esiste oggi.
						<br /><br />
						Queste immagini dovrebbero rendere l'idea di quanto sia cambiata Google&trade;, dalla sua nascita
						ad oggi.
						<br /><br />
						Se, al contrario, guardiamo, non so, l'Empire State Building, non vediamo cambiamenti architetturali così imponenti.
						<br /><br />
						Forse è proprio questa la differenza maggiore tra l'architettura tradizionale e quella software: 
						l'architettura software deve essere pensata per evolvere nel futuro. Spesso, nell'immediato futuro! 
						<br /><br />
						E, mi spiace: garantire l'<em>integrità concettuale</em> non offre alcuna tutela in questo senso!</td>
				</tr>
				<tr class="odd">
					<td>9</td>
					<td>
					Cosa significa questo? Che l'evoluzione di Google&trade; è frutto di design emergente, a colpi di TDD?
					<br />
					Voglio raccontarvi una storia.
					<br />
					<p>
						Michele lavora in un'azienda enterprise, e nel suo lavoro ha sempre bisogno di dati molto specifici. 
						Purtroppo, questi dati sono distribuiti su diverse applicazioni. 
						<br />
						Esclusivamente per Michele, uno sviluppatore crea un programma che recupera le
						informazioni da 3 applicazioni, A, B e C e le fornisce a Michele in un file spreadsheet, così che lui
						sia in grado di leggere il report e svolgere il proprio lavoro.
						<br /><br />
						Michele, però, si accorge di aver bisogno di quei dati ogni giorno. Così chiede che
						il programma di raccolta venga eseguito, automaticamente, tutte le mattine.
						<br /><br />
						Nessun problema: un sistemista crea un'attività schedulata per Michele. 
						<br /><br />
						Ecco, il risultato è che, apposta per Michele,
						è stato creato un vero &quot;Application Workflow&quot;, dipendente da un'attività schedulata e tre applicazioni. 
						<br /><br />
						Il fatto, Nicola, è che Michele non è il solo in azienda a voler aumentare la propria produttività.
						<br />
						Moltiplica la situazione di Michele per un migliaio di volte.
						<br /><br />
						Io chiamo il risultato &quot;Architettura a matassa&quot;.
						<br />
						Vedila come un'enorme blob, con fibre di connessione che vanno in ogni possibile direzione. Nessuno
						è in grado di districarla, e nessuno ne ha il controllo.
						<br /><br />
						Ora, mettiamo di aver bisogno di sostituire una delle applicazioni chiave, perché la sua tecnologia
						è datata o perché il fornitore smetterà di fornire supporto. 
						<br/>
						Ci sarà difficile, se non impossibile, capire quali siano le connessioni con quell'applicazione.
						<br /><br />
						Hai una rete infinita di dipendenze e, ironicamente, siamo noi stessi ad averla creata, anno dopo anno.
						<br />
						Ognuna delle connessioni era perfettamente ragionevole, nel momento in cui è stata introdotta, ma il risultato finale è talmente
						contorto che risulta impossibile apportare modifiche in un punto senza provocare danni in un altro.
						<br /><br />
						Ecco, è qui che opera <em>Enterprise Architecture</em>: aiuta a creare un ecosistema IT organizzato in modo
						che ognuno abbia la libertà di apportare dei miglioramenti, così che ci sia sempre spazio
						per l'innovazione. L'architettura fa in modo che l'ecosistema resti comunque sempre robusto, flessibile ed 
						efficiente. Questo richiede che esista un processo per mantenere le cose ordinate. 
						</p>
						Ecco: non si può pensare che un'azienda come Google&trade;, quando decide di aggredire il mercato mobile e inizia a sviluppare 
						un sistema operativo come Android, non parta da una strategia aziendale, nella testa dell'amministratore delegato
						e non la trasformi in una road map tecnologica.
						<br />
						<br />Il controllo di un ristretto gruppo di persone
						è molto più sensato di una totale mancanza di coordinamento.
						<br /><br />
						Cioè, non si può puoi pensare che tutto si riduca a far emergere l'architettura con cicli di red/green/refactor.
						<br /><br />
						È questo quel che sostiene Agile?
						<td></td>
				</tr>
				<tr class="even">
					<td>10</td>
					<td></td>
					<td>
						No, naturalmente; ma questo non necessariamente significa che tutto sia da attribuirsi alla centralizzazione del pensiero.
						<br />
						Parliamo di centralizzazione? Soprattutto nell'ultimo decennio, le critiche verso una gestione centralizzata e formale dell'architettura non sono certo mancate. Enterprise Architecture è effettivamente un'iniziativa che sta coinvolgendo sempre di più la maggioranza delle istituzioni finanziarie. Eppure c'è chi sostiene:
						<br /><br />
						<div class="quotation">
							<p>
							  &quot;<em>La maggioranza delle iniziative Enterprise Architecture ha fallito. Io stimo che in più del 90% dei casi non sia stato realizzato niente di utile</em>&quot;
							</p>
						</div>
						<br /><br />
						L'architettura ha molto più a che fare con la <em>conoscenza condivisa</em> e con la <em>visione comune</em> ed ha una connotazione più &quot;sociale&quot; che tecnica.
						<br />
				</tr>
				<tr class="odd">
					<td></td>
					<td>
						<p>
							Ok, scommetto che l'autore di questa frase sia proprio uno di quei guru
							&quot;agile&quot;; uno di quelli che occupano i palcoscenici delle
							conferenze raccontando che i manager sono inutili, che il mondo
							è degli sviluppatori e che tutti dovremmo iniziare ad
							abbracciare gli alberi.
							<br />
							Mi sto sbagliando?</p></td>
					<td></td>
				</tr>
				<tr>
					<td></td>
					<td></td>
						<td>
							<p>
								L'autore è <em>Ivar Jacobson</em>, uno degli autori di UML e di RUP, cioè
								di due strumenti tipicamente molto osteggiati da &quot;Agile&quot;.
							<p>
						</td>
				</tr>
				<tr class="odd">
					<td>11</td>
					<td>
						Ok, capisco.
						<br />
						Parliamo, allora, di quello che Agile propone, in alternativa ad &quot;Enterprise Architecture&quot;.
						<br /><br />
						Agile, in qualche modo, propugna l'idea di una struttura organizzativa piatta.
						<br />
						E questa è un'idea molto intrigante. Quello che può essere un po' fastidioso è che a volte si ha l'impressione che queste idee siano un po' naive: fanno sognare, fanno riferimento a principi molto democratici e accattivanti.
						<br />
						Però, io scelgo una metodologia <strong>non</strong> in funzione di quanto mi piaccia o di quanto sia in grado di appagare il mio ego.
						<br />
						Sicché, anche se un po' meno trendy, preferisco basare le mie scelte su proposizioni scientifiche.
						<br />
						Quindi domando, qual è il fondamento scientifico di quello che Agile sostiene?
						<br />
						Vi dico perché c'è la necessità di il livello di astrazione. 
						<br />
						Conoscete il Modello <em>Dreyfus</em> di &quot;Acquisizione Delle Competenze&quot;?
						<br />
						È stato ideato negli anni 80 da due docenti californiani. Non è una teoria campata per aria: anzi, ha avuto un grande impatto in campo infermieristico e aziendale.
						<br />
						Secondo questo modello, quando affrontiamo un problema nuovo, passiamo attraverso cinque fasi.
						<br />
						Inizialmente ci limitiamo ad applicare meccanicamente le regole.
						<br />
						Poi, gradualmente, acquisiamo autonomia e finiamo perfino per abbandonare le regole e affidarci all'intuito.
						<br />
						Guardate: alla base della piramide c'è il <em>novizio</em>. Aderisce alle regole: gli si dice cosa fare, e lui si limita ad eseguire, senza troppe domande.
						<br />
						Sopra abbiamo il <em>principiante</em>: segue le regole, come il novizio, ma inizia a collegarle alle situazioni in cui vanno applicate, inizia a porsi delle domande. È il caso del programmatore junior, che può affrontare da solo lo sviluppo di un componente se dispone di specifiche chiare, ma non è in grado di progettarlo da zero in autonomia.
						<br />
						Poi ci sono i <em>competenti</em>: persone capaci di gestire la complessità, di scindere vari fattori - anche quando interagiscono tra loro. Persone capaci di comprendere le conseguenze a lungo termine delle proprie azioni, pur senza coglierne tutte le implicazioni.
						<br />
						Arriviamo, poi, ai <em>proficient</em>: sono tecnici che affrontano il problema con una prospettiva differente, con un approccio olistico e sistemico. Soggetti che, osservando l'albero, sono in grado di visualizzare l'intera foresta.
						<br />
						Infine, abbiamo gli <em>esperti</em>, che adottano un approccio largamente intuitivo e ricorrono a mezzi analitici solo all'occorrenza, in situazioni nuove.
						<br />
						Ecco, i compiti di un architetto richiedono questo livello.
						<br />
						L'idea secondo la quale non vi sia effettivo bisogno di ruoli specifici - che in fondo, di fronte alla complessità, <em>siamo tutti uguali</em> - è molto romantica, ma manca di fondamento scientifico e rischia di apparire naive.</td>
				</tr>
				<tr class="even">
					<td>12</td>
					<td></td>
					<td>
						<br />
						Hai parlato di <em>sviluppatori junior che affrontano da soli lo sviluppo di un &quot;singolo componente&quot;</em>.
						<br />
						A proposito di questo, vorrei raccontare un aneddoto, partendo da uno snippet di codice:
						<br />
						Si tratta di una classica operazione di &quot;prelievo&quot; fondi.
						<br />
						Riuscite ad individuare la falla?</td>
				</tr>
				<tr class="even">
					<td></td>
					<td>
						Credo che ci possa essere una &quot;Race Condition&quot;.
						Naturalmente, a patto che il database non supporti transazioni ACID.
						<br />
						<br />
						Il problema emerge nel momento in cui il servizio bancario permette l'accesso concorrente.
						<br />
						Provo a descrivere il problema.
						<br /><br />
						Supponiamo che sul conto vi sia attualmente un bilancio di 1.000 EURO.
						<br />
						Mi connetto e decido di prelevare 100 EURO.
						<br />
						&quot;balance&quot; vale 1.000, &quot;amount&quot; vale 100, quindi, nella variabile
						&quot;new_balance&quot;, avrò 900 EURO.
						<br />
						Ora, prima di scrivere il valore di &quot;new_balance&quot; sul database, con una seconda connessione,
						accedo al medesimo conto, e chiedo ancora una volta di ritirare 100 EURO. 
						<br /><br />
						La prima riga viene nuovamente eseguita e dal database risulta ancora un bilancio pari a 1.000 EURO.
						<br />
						Che dire... fantastico! Sono in grado di prelevare 200 euro, facendomene addebitare solo 100!</td>
					<td></td>
				</tr>
				<tr class="odd">
					<td></td>
					<td></td>
					<td>
						Esatto!
						<br />
						In quel caso, la Race Condition si manifestava poiché l'engine era MongoDB, che non supporta nativamente transazioni ACID.
						<br /><br />
						Ecco: quel codice apparteneva a Flexcoin, una &quot;Bitcoin bank&quot;.
						<br />
						Un attacker è riuscito a sfruttare la Race Condition e a dilapidare i forzieri della banca,
						per un totale di circa mezzo milione di dollari.
						La spiacevole conclusione di questa vicenda vede Flexcoin chiudere i battenti, nel mese di marzo di quest'anno.
						<br />
						Impressionante, no?
						<br /><br />
						Se ci si riflette, tutto questo si traduce in un fallimento quasi &quot;sociale&quot;: è
						il fallimento dell'insegnamento accademico dei sistemi distribuiti.
						<br />
						Abbiamo educato gli sviluppatori
						equipaggiandoli con framework &quot;clear-thinking&quot;, cioè, 
						con ambienti &quot;magici&quot; e preconfezionati, che permettono loro di prescindere dagli aspetti 
						architetturali, nella speranza, come sostieni tu, che possano occuparsi in autonomia
						dello sviluppo del <em>singolo componente</em>; il quale, nella fattispecie, &#232
						l'operazione di prelievo, che è costata la sopravvivenza dell'azienda stessa.
						<br /><br />
						Ottimo risultato!</td>
				</tr>
				<tr class="even">
					<td></td>
					<td></td>
					<td>
						Detto questo, a me pare evidente che partiamo da basi molto differenti.
						<br />
						Possiamo riassumere asserendo che facciamo riferimento a due figure molto differenti di architetto?</td>
				</tr>
				<tr class="odd">
					<td>13</td>
					<td>
						Sì, il mio architetto è la persona che prende le decisioni importanti, quelle di più alto livello.
						Ad esempio, è colui che si preoccupa di adottare un engine che supporti transazioni ACID, 
						proprio per evitare incidenti come quello di Flexcoin.
						<br />
						Chiamiamolo <em>Architectus Reloadus</em>.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>14</td>
					<td></td>
					<td>
						Chiamiamo il mio <em>Architetto Ozyrus</em>.
						<br />
						Il mio architetto non così interessato a prendere decisioni importanti.</td>
				</tr>
				<tr class="odd">
					<td>15</td>
					<td></td>
					<td>
						L'attività più importante dell'architetto <em>Ozyrus</em> è fare da mentore per i team,
						in modo tale da consentire a ciascuno dei membri di raggiungere un livello di competenze tale da permettergli di affrontare autonomamente problematiche sempre più complesse.
						<br />
						Incrementare le abilità dei team consente all'architetto di svincolarsi dall'incombenza di fungere da solo &quot;decision maker&quot; e rimuove il rischio di gravare sull'intero processo come &quot;collo di bottiglia&quot;.</td>
				</tr>
				<tr class="even">
					<td>16</td>
					<td></td>
					<td>
						La metafora che mi sembra più appropriata è quella proposta da Mike Two: l'architetto è come una &quot;guida alpina&quot;; è la persona più skillata, che può insegnare agli altri membri come muoversi ed è sempre un riferimento nei momenti di maggior difficoltà.</td>
				</tr>
				<tr class="odd">
					<td>17</td>
					<td></td>
					<td>
						In questo senso, credo che il valore di un architetto sia inversamente proporzionale alla quantità di decisioni che è costretto a prendere.
						<br /><br />
						E, se ci si pensa, è una figura molto simile al Coach, in Extreme Programming.
						<br /><br />
						In sostanza, l'architetto realizza il suo compito quando ha reso il team autonomo.
					</td>
				</tr>
				<tr class="even">
					<td>18</td>
					<td>Quindi, stiamo parlando di una figura che si adopera per rendersi superflua?</td>
					<td></td>
				</tr>
				<tr class="odd">
					<td></td>
					<td></td>
					<td>In un certo senso, sì.</td>
				</tr>
				<tr class="even">
					<td>19</td>
					<td>
						A me appare tutto piuttosto fumoso e un po' distante dalle reali esigenze delle aziende enterprise, ma ne colgo il senso.
						<br /><br />
						Diciamo che il mio architetto sul piano puramente operativo è meno impegnato dell'architetto agile. 
						Magari è più interessato a creare una visione comune, allineata alle scelte di business.
						<br />
						Forse non è presente nelle singole scalate e lascia questo compito a degli alpini professionisti.
						Ecco, diciamo che il mio architetto è quello che si preoccupa di fornire alla spedizione una cartina dettagliata ed affidabile.
						<br />
						La guida, in un team, è indispensabile ma, ecco, senza una mappa porterà l'intera spedizione a prendere direzioni sbagliate.
						<br />
						Sapete perché credo che un lavoro di design up-front sia davvero molto importante?</td>
				</tr>
				<tr class="odd">
					<td>20</td>
					<td>
						Perché esistono delle decisioni che vanno prese con largo anticipo, prima che sia troppo tardi; prima di scoprire che le fondamenta sulle quali il progetto si reggeva erano inconsistenti. 
<br />
						Qui ho rappresentato le classiche fasi di sviluppo di un progetto, che vanno dal Concept, la raccolta dei requisiti,
						lo sviluppo e così via.
						<br />
						La mia tesi è che con il passare del tempo, il costo da sostenere per apportare una modifica aumenti. Cioè, col passare del
						tempo aumenti l'irreversibilità del processo
						<br />
						Ecco, quello è il compito dell'architetto: aiutare a definire quegli aspetti del design che sono più costosi da cambiare in corso d'opera.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>21</td>
					<td></td>
					<td>
						Probabilmente è questo il punto cruciale: si possono vedere le metodologie &quot;Agili&quot; come un sistema per contenere la complessità e ridurre l'irreversibilità.
						<br />
						Clasicamente, la complessità viene affrontata con la pianificazione: si cerca di minimizzare l'impatto negativo del cambiare idea in corso d'opera.
						<br />
						Io penso che cambiamento sia inevitabile, e mi adopero per affrontarlo. &quot;Embrace the change&quot;, è il mio motto. 
						<br />
						Chi pensa di poter pianificare tutto disegna piani come questo:
						<br /></td>
				</tr>
				<tr class="odd">
					<td>22</td>
					<td></td>
					<td>
						Purtroppo, per quante energie si investano nel predirre il futuro, la strada che ci si troverà di fronte assomiglierà più a questa:</td>
				</tr>
				<tr class="even">
					<td>23</td>
					<td></td>
					<td>
						Per cui, questa è la visione che si può avere del futuro.
						<br /><br />
						Io faccio leva sullo &quot;scope&quot;; avanzo per &quot;piccoli passi&quot;.
						<br /><br />
						Kent Beck usa una metafora molto convincente: quella della &quot;guida&quot;.
						<br /><br />
						&quot;<em>Guidare non è una questione di puntare la macchina nella giusta direzione.
						Guidare riguarda dare attenzione costante, apportando piccole correzioni prima in una direzione, e poi in un'altra.
						<br />
						Questa è l'essenza di XP: il cambiamento è l'unica costante.</em>&quot;.</td>
				</tr>
				<tr class="odd">
					<td>24</td>
					<td>
						Di nuovo, mi sembra un po' troppo vago.
						<br />
						È dal 1980 che Barry Boehm ha dimostrato, supportato da ampie statistiche, che il costo del software aumenta nel tempo.
						<br />
						Modificare il software in fase di analisi è molto più economico che in fase di sviluppo. Una volta arrivati alla produzione il costo diventa spesso proibitivo.
						<br />
						Molto meglio individuare un problema durante la raccolta dei requisiti, prima che il danno si manifesti in produzione.
						<br /><br />
						Perciò, un'analisi up-front può essere lo strumento che permette di contenere i costi di gestione.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>25</td>
					<td></td>
					<td>
						La scommessa di <em>eXtreme Programming</em> è proprio questa: se la curva dei costi fosse piatta, potremmo contare sul fatto 
						che cambiare il codice sia sempre un'operazione economica, in fase di design come in produzione.
						Se ipoteticamente la curva dei costi fosse più piatta, ci comporteremmo in modo completamente differente da come abbiamo sempre fatto.
						<br /><br />
						Per esempio, invece di pianificare tutto al minimo dettaglio, cercheremmo di rimandare le decisioni, 
						semplicemente per avere più tempo a disposizione per indagare sul problema.
						<br />
						
						<br />
						La buona notizia è che appiattire la curva dei costi è possibile. Non è un risultato che arriva gratuitamente,
						ma è comunque una cosa possibile. Esistono diverse	tecniche, in programmazione,
						che consentono di rendere economica la modifica del codice.	 Test-Driven development è un esempio, ma in generale lo sono
						tutte le tecniche che mirano a ridurre l'accoppiamento, incrementare la coesione, evitare la regressione e distribuire la conoscenza. 
						<br /><br />
						Questa è la scommessa. E questo, ovviamente, cambia molto il ruolo e gli obiettivi dell'architetto. 
						<br /><br />
						Si passa dall'obiettivo di <em>fare piani</em> all'obiettivo di <em>creare le condizioni per permettere ai piani di svilupparsi</em>,
						giorno dopo giorno.
</td>
				</tr>
				<tr class="odd">
					<td>26</td>
					<td>
						Enterprise Architecture non rifiuta queste tecniche!
						<br />
						 La questione non è osteggiare TDD. La questione è: questo è sufficiente a far emergere un'architettura?
						<br /><br />
						Si può essere eccellenti muratori e saper erigere case meravigliose e incrollabili. Anzi, è importantissimo che i muratori siano eccellenti.
						<br />
						Ma mille bravi muratori non garantiscono una città con una tangenziale senza ingorghi di traffico.
						<br /><br />
						Cosa propongono di diverso, i nostri due architetti, per costruire, debuggare e manutenere un sistema informatico con un alto grado di complessità?</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>27</td>
					<td>
						Io suggerisco che si ricorra ad un'autorità, un esperto che possa occuparsi di congegnare il sistema senza doversi occupare dei dettagli implementativi, perché è evidente che il suo tempo sarà particolarmente prezioso.
						Fintanto che il team sarà in grado di seguire le linee guida, la qualità del medesimo verrà garantita.</td>
					<td></td>
				</tr>
				<tr class="odd">
					<td>28</td>
					<td></td>
					<td>
						Al contrario, io ritengo che questo approccio porti a rallentamenti e finger pointing.
						Con un sistema simile è chiaro che, in una discussione, chi avrà maggiore autorità uscirà sempre vincitore.
						Anzi, peggio: gli sviluppatori verranno accusati di non essere buoni &quot;team player&quot;, solo perché hanno contestato l'architetto</td>
				</tr>
				<tr class="even">
					<td>29</td>
					<td></td>
					<td>
						Piuttosto, propongo che l'architetto sia coinvolto anche nell'implementazione. È necessario che sia costantemente informato sui cambiamenti e sull'impatto che questi producono sul design.</td>
				</tr>
				<tr class="odd">
					<td>30</td>
					<td>
						Esasperando le diversità dei due approcci, mi sembra di capire che il nodo della questione è che io propongo la figura di un architetto dedicato</td>
				</tr>
				<tr class="even">
					<td>31</td>
					<td></td>
					<td>E io faccio invece leva sulla condivisione della responsabilità</td>
				</tr>
				<tr class="odd">
					<td>32</td>
					<td>Il mio approccio pone maggiore focus sul design-upfront.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>33</td>
					<td></td>
					<td>Il mio su un'architettura evolutiva.</td>
				</tr>
				<tr class="odd">
					<td>34</td>
					<td>Oppure, per usare le parole del &quot;Manifesto Agile&quot;, io faccio affidamento sulla <em>Comprehensive Documentation</em>.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td></td>
					<td></td>
					<td>Io, invece, mi affido alla concretezza del <em>Working Software</em>.</td>
				</tr>
				<tr class="odd">
					<td></td>
					<td>
						Bene.
						<br />
						Ecco, fammi capire perché l'architetto deve restare costantemente informato anche sui dettagli implementativi.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>35</td>
					<td></td>
					<td>
					Certamente.
					<br />
					Sì: si capisce molto bene con un <em>Influence Diagram</em>.
					<br />
					Considera il rapporto tra il mangiare e il prendere peso. Più mangio, più ingrasso. è una influenza positiva. La rappresento in questo modo:
					<br />
					
					<br /></td>
				</tr>
				<tr class="odd">
					<td>36</td>
					<td></td>
					<td>
						Il rapporto tra l'esercizio fisico e il peso è opposta: più sport faccio, meno ho problemi di peso.
						<br/>
						Cioè, l'esercizio fisico ha un'influenza negativa sull'aumento di peso. La rappresento sovrapponendo un cerchio alla linea. Mi segui?</td>
				</tr>
				<tr class="even">
					<td>37</td>
					<td></td>
					<td>
						Ok, come puoi notare ho rappresentato un circolo vizioso.
						<br />
						Parti dalla freccia che entra nel circolo.
						<br />
						Leggila in questo modo:
						<br />
						Più ingrasso, più perdo stima in me stesso.
						<br />
						Più perdo stima, più mangio.
						<br />
						Più mangio, più ingrasso.
						<br />
						E mi ritrovo nuovamente all'ingresso del circolo visioso.</td>
				</tr>
				<tr class="odd">
					<td></td>
					<td>Perché mi racconti questo?</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>38</td>
					<td></td>
					<td>
						Perché questo ha molto a che fare con i feedback che un architetto può ricevere. Lascia che ti spieghi. <br />
						Quì ho rappresentato lo stesso identico circolo vizioso, ma ho usato dei termini che riguardano la gestione di un team. Leggilo così:
						<br />
						Più pressioni imponi ad un team, più gli sviluppatori faranno cowboy programming. Per esempio, tireranno via sui test, perché non darai loro il tempo;
						<br /><br />
						ma il cowboy programming ha un effetti negativo sulla qualità del codice, per cui si produrrà un codice tendenzialmente meno corretto.
						<br /><br />
						E, con più errori, è evidente che sarai costretto a far maggiore pressione, per far rispettare le scadenze.
						<br /><br />
						È un circolo vizioso.</td>
				</tr>
				<tr class="odd">
					<td></td>
					<td>D'accordo.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>39</td>
					<td></td>
					<td>
						Ecco, arriviamo al punto del perché l'architetto debba essere coinvolto anche nello sviluppo.
						<br />
						Questo diagramma di influenza descrive il tuo approccio:
						<br />
						Parti dalla freccia in ingresso al diagramma, cioè dalla decisione di produrre molta documentazione.
						<br />
						Tanta più documentazione tu architetto produci, minore è il numero di feedback diretti che ricevi;
						<br />
						Purtroppo, meno feedback ricevi, maggiore sarà il numero di scelte errate compiute dal team.
						<br />
						E, a fronte di un alto numero di scelte sbagliate, ti sarà necessario produrre documentazione.
						<br />
						Come vedi, anche in questo caso siamo di fronte ad un circolo vizioso.</td>
				</tr>
				<tr class="odd">
					<td></td>
					<td>E tu cosa proponi in alternativa?</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>40</td>
					<td></td>
					<td>
						Guarda, ti mostro come sia possibile invertire la tendenza.
						<br />
						Parto dalla decisione di avere molta collaborazione, piuttosto che molta documentazione. Se faccio leva sulla collaborazione, produco molti feedback;
						<br />
						Questo riduce il numero di scelte errate.
						<br />
						Avere meno scelte errate permette di abbattere il numero di documenti prodotti e, quindi, di avere maggior tempo a disposizione per una collaborazione intensiva.
						<br />
						Come puoi constatare, il modello che propongo alimenta un circolo virtuoso!</td>
				</tr>
				<tr class="odd">
					<td></td>
					<td>Quindi, quale è l'alternativa ad &quot;Enterprise Architecture&quot;?</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>41</td>
					<td></td>
					<td>
						Agile propone: <em>Individuals and interactions over processes and tools</em>.
						<br /><br />
						Spesso, al governo centralizzato si accompagna la tendenza a standardizzare e a convergere verso una singola piattaforma tecnologica.
						<br />
						Ma l'esperienza ci insegna che non tutti i problemi sono chiodi e, di conseguenza, non tutte le soluzioni sono martelli.
						<br /><br />
						Il trend, in questi anni, è di costruire sistemi organizzati come micro-service.
						<br />
						Molti team, piuttosto che affidarsi a standard scritti su qualche documento, da qualcuno sopra di loro, preferiscono produrre tool utili che altri sviluppatori possano utilizzare per risolvere problemi simili. 
						<br />
						Nascono le API e, assieme a loro, delle &quot;community&quot;.
						<br />
						Se ci pensi bene, Amazon™ rappresenta un caso molto significativo.</td>
				</tr>
				<tr class="odd">
					<td>42</td>
					<td>
						Mi trovi molto d'accordo.
						<br />
						E penso sia molto curioso che tu concluda citando Amazon™. 
						<br />
						Perché, se ricordi il famoso post di Steve Yegge ricorderai che Amazon™ è passata dall'essere un e-commerce di libri ad una piattaforma di servizi per la decisione illuminata di un architetto visionario e autoritario.
						<br />
						Probabilmente, se si fosse aspettato che Amazon™ diventasse una immensa Service Oriented Company, per l'intervento dei suoi singoli sviluppatori, come architettura emergente, oggi non avremmo il &quot;Cloud&quot; di Amazon™.
						<br />
						Ma è bello vedere che le nostre visioni, apparentemente così distanti, abbiano alla fine così tanti punti di contatto.</td>
					<td></td>
				</tr>
				<tr class="even">
					<td>43</td>
					<td></td>
					<td>Sì. Voi cosa ne pensate? Ne parliamo?</td>
				</tr>
			</tbody>
		</table>
	</body>
</html>
